use scraper::{Html, Selector};
use std::thread::sleep;
use std::time;
use std::cmp::max;
use nano_get;
use crate::http_client::Client;

fn request(link: &str) -> nano_get::Request {
    match nano_get::Request::default_get_request(link) {
        Err(e) => {
            println!("{:#?}", e);
            request(link)
        },
        Ok(a) => a
    }
}

fn load(link: &str) -> nano_get::Response {
    match request(link).execute() {
        Err(e) => {
            println!("{:#?}", e);
            sleep(time::Duration::from_millis(6000));
            load(&link)
        },
        Ok(a) => a
    }
}

pub fn load_link(link: &str) -> String {
    let mut status = 0;

    let mut body = "".to_string();

    let mut iteration: u64 = 1;

    while status != 200 && status != 404 {
        let resp = load(link);

        status = match resp.get_status_code() {
            Some(code) => code,
            None => 600
        };

        body = resp.body;

        println!("{}", &status);

        if status != 200 {
            sleep(time::Duration::from_millis(100 * iteration));
            iteration = iteration + 1;
        } else {
            sleep(time::Duration::from_millis(100));
            iteration = 1;
        }
    };

    body.to_string()
}

pub fn get_years(link: &str) -> Vec<String> {
    println!("Get list of years...");

    let mut years: Vec<String> = vec![];

    let body = load_link(&(link.to_owned() + "?pn=0"));

    let document = Html::parse_document(&body);

    let selector = Selector::parse("select[name=year]").unwrap();
    let option = Selector::parse("option").unwrap();

    for element in document.select(&selector) {
        for option in element.select(&option) {
            years.push(option.inner_html());
        }
    }

    years.reverse();

    println!("...{}", &years.join(", "));

    years
}

pub fn get_years_2(http: &mut Client) -> Vec<String> {
    println!("Get list of years...");

    let mut years: Vec<String> = vec![];

    let body = http.body().unwrap();

    let document = Html::parse_document(&body);

    let selector = Selector::parse("select[name=year]").unwrap();
    let option = Selector::parse("option").unwrap();

    for element in document.select(&selector) {
        for option in element.select(&option) {
            years.push(option.inner_html());
        }
    }

    years.reverse();

    println!("...{}", &years.join(", "));

    years
}

pub fn get_year_page_count(link: &str, year: &str) -> u16 {
    println!("Get page count of {} year...", &year);

    let body = load_link(&(link.to_owned() + &format!("?year={}", &year)));

    let document = Html::parse_document(&body);

    let selector = Selector::parse("div#pager_wrapper").unwrap();
    let a = Selector::parse("a").unwrap();

    let links = document
        .select(&selector).next().unwrap()
        .select(&a);

    let mut real_count = 0;

    for link in links {
        let href = &link.value().attr("href").unwrap()[1..];

        let count_query: Vec<&str> = href.split("&").collect();

        let count: u16 = count_query[0][3..].parse::<u16>().unwrap();

        real_count = max(real_count, count)
    }

    println!("{:#?}", &real_count);

    real_count
}